(ns upgradingdave.practice.euler)

(defn divisible?
  "Return true if x is divisible by y"
  [x y]
  (= (mod x y) 0))

(defn divisible-fn
  "Return a function that returns true if x is divisible by y"
  [y]
  (fn [x] (divisible? x y)))

(defn not-divisible-fn
  "Return a function that returns false if x is divisible by y"
  [y]
  (fn [x] (not (divisible? x y))))

(defn problem1
  "If we list all the natural numbers below 10 that are multiples of 3
  or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find
  the sum of all the multiples of 3 or 5 below 1000."
  [ns]
  (letfn [(by3or5? [n]  (or (divisible? n 3) (divisible? n 5)))]
    (transduce (filter by3or5?) + ns)))

(defn fibonacci 
  ([] (fibonacci 0 1))
  ([x y]
   (lazy-seq (cons (+ x y) (fibonacci y (+ x y))))))

(defn problem2 [maximum]
  "Each new term in the Fibonacci sequence is generated by adding the
  previous two terms. By starting with 1 and 2, the first 10 terms
  will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the
  terms in the Fibonacci sequence whose values do not exceed four
  million, find the sum of the even-valued terms."
  (reduce + (filter even? (take-while #(< % maximum) (fibonacci)))))

(defn divisibles 
  "Infinite list of all numbers divisible by n"
  [n]
  (filter #(divisible? % n) (range)))

(defn not-divisibles 
  "Infinite list of all numbers not divisible by n starting at x"
  [x n]
  (filter #(not (divisible? % n)) (map #(+ x %) (range))))

(defn range-from
  "Just like `range` except can pass the start rather than end"
  [start]
  (map #(+ start %) (range)))

(defn eratosthenes-infinite
  "Sieve of erotosthenes that produces infinite list. this is pretty
  slow because it's not possible to make eliminations further out than
  the current largest prime. So we end up recalculating the
  eliminations which grows linearly with the size of largest prime."
  ([] (eratosthenes-infinite [2] [(not-divisible-fn 2)]))
  ([primes filters] 
   (let [next       (last primes)
         filters    (conj filters (not-divisible-fn next))
         f          (apply juxt filters)
         next-prime (first 
                     (filter #(every? identity (f %)) 
                             (range-from (inc next))))]
     (lazy-seq (cons 
                next
                (eratosthenes-infinite (conj primes next-prime) filters))))))

;; Before using transients:
;; "Elapsed time: 17823.110712 msecs"
;; After using transients: 
;; "Elapsed time: 7625.619143 msecs"
(defn- sieve 
  "acc should be a vector of booleans with index starting at 2 and
  ending at n. i is the most recently found prime. The result is a
  vector of booleans with multiples of i marked as false"
  [n i acc]
  (loop [j (Math/round (Math/pow (bigint i) 2)) k 0 acc (transient acc)]
    (if (> j n)
      (persistent! acc)
      (recur (+ (Math/round (Math/pow (bigint i) 2)) (* (inc k) i)) (inc k)
             (assoc! acc (- j 2) false)))))

(defn eratosthenes
  "Sieve of erotosthenes. Find all primes less than n"
  [n] 
  (loop [i 2 acc (into [] (range 2 n))]
    (if (> i (Math/sqrt n))
      acc
      (recur (inc i) (sieve n i acc)))))

(defn primes 
  "infinite version is slow"
  ([]  (eratosthenes-infinite))
  ([n] (eratosthenes n)))


;; lucas numbers 
;; If a number fails the lucas test, it's definitely NOT prime
;; start with 1 and 3
;; 1, 3, 4, 7, 11, 18, etc
;; is 5 prime?
;; find the 5th lucas number = 11
;; subtract one = 10
;; if 5 is a factor of 10 then it's probably prime

;; is 6 prime? 
;; find the 6th lucas number = 18
;; subtract 1 = 17
;; if 6 is not a factor of 17 therefore, it's definitely NOT prime

;; Lucas-Lehmer Numbers
;; start with 4
;; square the previous number and subtract 2
;; 4, 14, 194, 37634, etc
;; Unfortunately, lucas lehmer numbers can only find primes of the
;; form 2^n - 1 (like 7)

(defn factors 
  "find all factors of n"
  [n]
  (loop [acc [] x 1]
    (if (>= x n)
      acc
      (if (divisible? n x)
        (recur (conj acc x) (inc x))
        (recur acc (inc x))))))

(defn prime-factors [n]
  "Find prime factors of n. (This probably won't complete for large
  values)"
  (let [fs (factors n)
        ps (take-while #(< % (inc (last fs))) (primes))]
    (filter #(some #{%} ps) fs)))

(defn prime? [n]
  (loop [x (Math/round (Math/sqrt 4))]
    (if (<= x 1)
      true
      (if (and (not (= x n))
               (divisible? n x))
        false
        (recur (dec x))))))

(defn problem3 
  "Find the largest prime factor of n"
  [n]
  (loop [x n p 2]
    (if (= x p)
      x
      (if (divisible? x p)
        (recur (/ x p) 2)
        (recur x (inc p))))))


(defn palindrome?
  "Return true if number is a palindromic number (reads the same both ways)"
  [^Integer n]
  (let [s (str n)]
    (if (not (empty? s))
      (loop [s s]
        (if (= (count s) 1)
          true
          (if (and (= (count s) 2) (= (first s) (last s)))
            true
            (if (= (first s) (last s))
              (recur (.substring s 1 (dec (count s)))))))))))

(defn problem4
  "Find the largest palindrome made from the product of two 3-digit numbers"
  [digits]
  (let [largest (Integer/parseInt (apply str (take digits (repeat 9))))]
    (apply max
     (filter #(not (nil? %))
             (for [x (range largest 1 -1) y (range largest 1 -1)]
               (let [r (* x y)]
                 (if (palindrome? r)
                   r)))))))

(defn problem5
  "2520 is the smallest number that can be divided by each of the
  numbers from 1 to 10 without any remainder. 

  What is the smallest positive number that is evenly divisible by all
  of the numbers from 1 to 20?" 
  [n]
  (loop [i n] ;; continue to increment i until we find an answer
    (if (loop [j 1] ;; j is 1 to 20
          (if (and (= j n) ((divisible-fn j) i))
            i
            (if (and (< j n) ((divisible-fn j) i))
              (recur (inc j)))))
      i
      (recur (+ i n)))

    ;; this is too slow because it's brute force
    ;; (if (every? identity (map #((divisible-fn %) i) (range 1 (inc n))))
    ;;   i
    ;;   (recur (inc i)))
))

;; Math.pow((double)first, (double)second));
(defn exp [x n]
  (reduce * (repeat n x)))

(defn sum-of-squares [n]
  (reduce + 0 (map #(exp % 2) (range 1 (inc n)))))

(defn square-of-sum [n]
  (exp (reduce + 0 (range 1 (inc n))) 2))

(defn problem6 "The sum of the squares of the first ten natural
  numbers is, 1^2 + 2^2 + ... + 10^2 = 385.
  
  The square of the sum of the first ten natural numbers is,
  (1 + 2 + ... + 10)^2 = 55^2 = 3025.

  Hence the difference between the sum of the squares of the first ten
  natural numbers and the square of the sum is 3025 − 385 = 2640. Find
  the difference between the sum of the squares of the first one
  hundred natural numbers and the square of the sum."
  [n]
  (- (square-of-sum  n) (sum-of-squares n)))

(defn problem7 
  "By listing the first six prime numbers: 2, 3, 5, 7,
  11, and 13, we can see that the 6th prime is 13. What is the 10
  001st prime number?"
  [n]
  (last (take n (primes))))

(def digits1000 
  7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)

(defn problem8
"The four adjacent digits in the 1000-digit number that have the
  greatest product are 9 × 9 × 8 × 9 = 5832.

  Find the thirteen adjacent digits in the 1000-digit number that have
  the greatest product. What is the value of this product?"
  [partition-size]
  (loop [l (partition partition-size 1 (str digits1000)) largest 0]
    (let [[x & xs] l 
          n        (map #(Character/getNumericValue %) x)
          product  (apply * n)]
      (if (nil? x)
        largest
        (if (> product largest)
          (recur xs product)
          (recur xs largest))))))

(defn is-square [n]
  (let [sqrt (Math/sqrt n)
        result (re-matches #"\d+\.0$" (str sqrt))]
    (if result (int sqrt))))

(defn pythagorean-triplets 
  "list of pythagorean triplets"
  [n]
  (filter identity
          (for [x (range 1 n) y (range 1 n)] 
            (if (> x y)
              (if-let [z (is-square (+ (* x x) (* y y)))]
                [x y z])))))

(defn problem9 [n]
  (apply * (first
            (filter (fn [[x y z]] (= (+ x y z) n)) 
                    (pythagorean-triplets n)))))

(defn problem10 
  "Find sum of all primes below n"
  [n]
  (apply + (take-while #(< % n) (primes))))


(def grid
  [[ 8  2 22 97 38 15  0 40  0 75  4  5  7 78 52 12 50 77 91  8]
   [49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48  4 56 62  0]
   [81 49 31 73 55 79 14 29 93 71 40 67 53 88 30  3 49 13 36 65]
   [52 70 95 23  4 60 11 42 69 24 68 56  1 32 56 71 37  2 36 91]
   [22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80]
   [24 47 32 60 99  3 45  2 44 75 33 53 78 36 84 20 35 17 12 50]
   [32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70]
   [67 26 20 68  2 62 12 20 95 63 94 39 63  8 40 91 66 49 94 21]
   [24 55 58  5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72]
   [21 36 23  9 75  0 76 44 20 45 35 14  0 61 33 97 34 31 33 95]
   [78 17 53 28 22 75 31 67 15 94  3 80  4 62 16 14  9 53 56 92]
   [16 39  5 42 96 35 31 47 55 58 88 24  0 17 54 24 36 29 85 57]
   [86 56  0 48 35 71 89  7  5 44 44 37 44 60 21 58 51 54 17 58]
   [19 80 81 68  5 94 47 69 28 73 92 13 86 52 17 77  4 89 55 40]
   [ 4 52  8 83 97 35 99 16  7 97 57 32 16 26 26 79 33 27 98 66]
   [88 36 68 87 57 62 20 72  3 46 33 67 46 55 12 32 63 93 53 69]
   [ 4 42 16 73 38 25 39 11 24 94 72 18  8 46 29 32 40 62 76 36]
   [20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74  4 36 16]
   [20 73 35 29 78 31 90  1 74 31 49 71 48 86 81 16 23 57  5 54]
   [ 1 70 54 71 83 51 54 69 16 92 33 48 61 43 52  1 89 19 67 48]])

(defn cmp-left [grid]
  (apply max 
   (for [row grid]
     (loop [n (partition 4 1 row) max -1]
       (let [[x & xs] n
             p (apply * x)]
         (if (nil? x) 
           max
           (if (> p max)
             (recur xs p)
             (recur xs max))))))))

(defn cmp-down [grid]
  (let [new-grid
        (let [grid' (atom (into [] (for [_ (range (count grid))] [])))]
          (doseq [[i row] (map-indexed #(vector %1 %2) grid)]
            (doseq [[j n] (map-indexed #(vector %1 %2) row)]
              (swap! grid' assoc-in [j i] n)))
          @grid')]
    (cmp-left new-grid)))

(defn cmp-diag-x1 [grid]
  (loop [x 0 y 0 res []]
    (let [row (loop [i x j y acc []]
                (if (>= j 20) 
                  acc
                  (recur (inc i) (inc j) 
                         (conj acc (get-in grid [i j])))))]
      (if (>= y 20) 
        (cmp-left res)
        (recur x (inc y) (conj res row))))))

(defn cmp-diag-x2 [grid]
  (loop [x 0 y 0 res []]
    (let [row (loop [i x j y acc []]
                (if (< j 0) 
                  acc
                  (recur (inc i) (dec j) 
                         (conj acc (get-in grid [i j])))))]
      (if (>= y 20) 
        (cmp-left res)
        (recur x (inc y) (conj res row))))))

(defn cmp-diag-y1 [grid]
  (loop [x 0 y 0 res []]
    (let [row (loop [i x j y acc []]
                (if (>= i 20) 
                  acc
                  (recur (inc i) (inc j) 
                         (conj acc (get-in grid [i j])))))]
      (if (>= x 20) 
        (cmp-left res)
        (recur (inc x) y (conj res row))))))

(defn cmp-diag-y2 [grid]
  (loop [x 0 y 19 res []]
    (let [row (loop [i x j y acc []]
                (if (>= i 20) 
                  acc
                  (recur (inc i) (dec j) 
                         (conj acc (get-in grid [i j])))))]
      (if (>= x 20) 
        (cmp-left res)
        (recur (inc x) y (conj res row))))))

;; Want to understand this
;; (defn parse-row [row]
;;   (map #(Integer. %) (clojure.string/split row #" ")))

;; (def data (map parse-row '(
;;   "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08"
;;   "49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00"
;;   "81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65"
;;   "52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91"
;;   "22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80"
;;   "24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50"
;;   "32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70"
;;   "67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21"
;;   "24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72"
;;   "21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95"
;;   "78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92"
;;   "16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57"
;;   "86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58"
;;   "19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40"
;;   "04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66"
;;   "88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69"
;;   "04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36"
;;   "20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16"
;;   "20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54"
;;   "01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48")))

;; (defn shoot-from [x y dx dy n]
;;   (map #(vector (+ x (* % dx)) (+ y (* % dy))) (range 0 n)))

;; (defn cells [size]
;;   (for [x (range 0 size) y (range 0 size)] (vector x y)))

;; (defn in-board [cell size]
;;   (let [valid? #(and (<= 0 %) (< % size))]
;;     (and (valid? (nth cell 0)) (valid? (nth cell 1)))))

;; (defn is-valid [path size]
;;   (every? #(in-board % size) path))

;; (def paths 
;;   (filter #(is-valid % 20) 
;;     (let [c (cells 20)]
;;       (concat 
;;         (map #(shoot-from (nth % 0) (nth % 1) 0 1 4) c)
;;         (map #(shoot-from (nth % 0) (nth % 1) 1 0 4) c)
;;         (map #(shoot-from (nth % 0) (nth % 1) 1 1 4) c)
;;         (map #(shoot-from (nth % 0) (nth % 1) (- 1) 1 4) c)))))

;; (defn cell-value [cell]
;;   (let [x (nth cell 0) y (nth cell 1)]
;;     (nth (nth data y) x)))

;; (defn path-value [path]
;;   (reduce * (map cell-value path)))

;; (reduce max (map path-value paths))

(defn problem11 []
  (max (cmp-diag-x1 grid) 
       (cmp-diag-x2 grid) 
       (cmp-diag-y1 grid) 
       (cmp-diag-y2 grid)))
